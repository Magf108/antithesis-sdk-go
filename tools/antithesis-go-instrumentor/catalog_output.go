package main

import (
	"fmt"
	"io"
	"os"
	"path"
	"strings"
	"text/template"
)

type GenInfo struct {
	ExpectedVals               []*AntExpect
	ExpectPackageName          string
	InstrumentationPackageName string
	SymbolTableName            string
	NeedsCoverage              bool
	EdgeCount                  int
	HasAssertions              bool
	ConstMap                   map[string]bool
}

const GENERATED_SUFFIX = "_antithesis_catalog.go"

func expect_output_file(dest_name string) (*os.File, error) {
	dest_file := os.Getenv("GOFILE")
	if dest_file == "" {
		dest_file = dest_name
	}
	dir_name, file_name := path.Split(dest_file)
	ext := path.Ext(file_name)
	if len(ext) > 0 {
		file_name = strings.TrimSuffix(file_name, ext)
	}
	generated_name := fmt.Sprintf("%s%s", file_name, GENERATED_SUFFIX)
	output_file_name := path.Join(dir_name, generated_name)

	var file *os.File
	var err error
	if file, err = os.OpenFile(output_file_name, os.O_RDWR|os.O_CREATE, 0644); err != nil {
		file = nil
	}
	if file != nil {
		if err = file.Truncate(0); err != nil {
			file = nil
		}
	}
	if err == nil {
		logger.Printf("Generated file: %q\n", output_file_name)
	} else {
		logger.Printf("Unable to generate file: %q\n", output_file_name)
	}
	return file, err
}

func assertion_name_repr(s string) string {
	if s == "Reachable" || s == "Unreachable" {
		return fmt.Sprintf("%s(message, values)", s)
	}
	return fmt.Sprintf("%s(message, cond, values)", s)
}

func hit_repr(b bool) string {
	if !b {
		return "not_hit"
	}
	return "was_hit"
}

func cond_repr(b bool) string {
	if b {
		return "cond_true"
	}
	return "cond_false"
}

func must_hit_repr(b bool) string {
	if b {
		return "must_be_hit"
	}
	return "optionally_hit"
}

func expecting_repr(b bool) string {
	if b {
		return "expecting_true"
	}
	return "expecting_false"
}

func assert_type_repr(s string) string {
	var repr_text = "reachability_test"

	switch s {
	case "every":
		repr_text = "universal_test"
	case "some":
		repr_text = "existential_test"
	case "none":
		repr_text = "reachability_test"
	}
	return repr_text
}

func uses_const(cm map[string]bool, c string) bool {
	return cm[c]
}

func generate_expects(module_name string, gen_info *GenInfo) {
	var tmpl *template.Template
	var err error

	const expector = `package main

// ----------------------------------------------------
// Generated by Antithesis instrumentor - do not modify
// ----------------------------------------------------

{{if .HasAssertions -}}import "{{.ExpectPackageName}}"{{- end}}
{{if .NeedsCoverage -}}import "{{.InstrumentationPackageName}}"{{- end}}

{{if .NeedsCoverage -}}func init() {
  instrumentation.InitializeModule("{{.SymbolTableName}}", {{.EdgeCount}})
}{{- end}}

{{if .HasAssertions -}}
func init() {

{{if uses_const .ConstMap "cond_false"}}  const cond_false = false{{- end}}
{{if uses_const .ConstMap "cond_true"}}  const cond_true = true {{- end}}
  const was_hit = true
{{if uses_const .ConstMap "not_hit"}}  const not_hit = !was_hit {{- end}}
{{if uses_const .ConstMap "must_be_hit"}}  const must_be_hit = true {{- end}}
{{if uses_const .ConstMap "optionally_hit"}}  const optionally_hit = false {{- end}}
{{if uses_const .ConstMap "expecting_true"}}  const expecting_true = true {{- end}}
{{if uses_const .ConstMap "expecting_false"}} const expecting_false = false {{- end}}
{{if uses_const .ConstMap "universal_test"}}  const universal_test = "every" {{- end}}
{{if uses_const .ConstMap "existential_test"}}  const existential_test = "some" {{- end}}
{{if uses_const .ConstMap "reachability_test"}}  const reachability_test = "none" {{- end}}

  var no_values map[string]any = nil
	
	{{- range .ExpectedVals }}
	{{- $cond := cond_repr .AssertionFuncInfo.Condition -}}
	{{- $did_hit := hit_repr false -}}
	{{- $must_hit := must_hit_repr .AssertionFuncInfo.MustHit -}}
	{{- $expecting := expecting_repr .AssertionFuncInfo.Expecting -}}
	{{- $assertion_name := assertion_name_repr .Assertion -}}
	{{- $assert_type := assert_type_repr .AssertionFuncInfo.AssertType}}

  // {{$assertion_name}}
  assert.AssertRaw("{{.Message}}", {{$cond}}, no_values, "{{.Classname}}", "{{.Funcname}}", "{{.Filename}}", {{.Line}}, {{$did_hit}}, {{$must_hit}}, {{$expecting}}, {{$assert_type}})
	{{- end}}
}
{{- end}}
`

	tmpl = template.New("expector")

	tmpl = tmpl.Funcs(template.FuncMap{
		"hit_repr":            hit_repr,
		"cond_repr":           cond_repr,
		"must_hit_repr":       must_hit_repr,
		"expecting_repr":      expecting_repr,
		"assert_type_repr":    assert_type_repr,
		"assertion_name_repr": assertion_name_repr,
		"uses_const":          uses_const,
	})

	if tmpl, err = tmpl.Parse(expector); err != nil {
		panic(err)
	}

	var out_file io.Writer
	if out_file, err = expect_output_file(module_name); err != nil {
		panic(err)
	}

	if err = tmpl.Execute(out_file, gen_info); err != nil {
		panic(err)
	}
}
